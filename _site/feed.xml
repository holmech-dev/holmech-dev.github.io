<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-12-11T23:09:11+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Chris Holmes</title><author><name>C. Holmes</name></author><entry><title type="html">Docker &amp;amp; Ros</title><link href="http://localhost:4000/2023/11/24/Docker-&-ROS.html" rel="alternate" type="text/html" title="Docker &amp;amp; Ros" /><published>2023-11-24T00:00:00+00:00</published><updated>2023-11-24T00:00:00+00:00</updated><id>http://localhost:4000/2023/11/24/Docker-&amp;-ROS</id><content type="html" xml:base="http://localhost:4000/2023/11/24/Docker-&amp;-ROS.html"><![CDATA[<p>This post outlines how to create a Docker environment with ROS middleware setup.</p>

<p>Docker offers a great amount of portability when it comes to preparing software environments, this lends well when developing applications with middleware such as ROS (Robotics Operating System) where managing a large amount of software libraries and portability maybe necessary.</p>

<p>To create the Docker environment a Docker image is needed, this will serve as our template or environment snapshot for creating our Docker container. A container is the instantiation of this image that we can work in. To build the image, we first need a way to instruct the build process what should be contained in the image, this is done with a Dockerfile.</p>

<p><img src="/docker_image_container.png" alt="Docker Image" /></p>

<p>I use knowledge about my system requirements to create the Dockerfile. For this build, I have the following requirements.</p>
<ul>
  <li>Ubuntu 20 - Operating system compatibility</li>
  <li>Noetic - ROS Version</li>
  <li>OpenCV 4.4.0 - Library Version</li>
  <li>CUDA - Nvidia GPU utilisation</li>
</ul>

<p>First, let’s create a Dockerfile. Create this file in a suitable directory necessary to store the docker files for you project.</p>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">holmech@linux-desktop:~$</span><span class="w"> </span><span class="nb">touch </span>Dockerfile.base
</code></pre></div></div>

<h2 id="updating-the-dockerfile">Updating the Dockerfile</h2>
<p>In a text editor if your choosing, the Dockerfile can now be edited. I’m using VS Code.
Using the <code class="language-plaintext highlighter-rouge">FROM</code> command, a base image is specified as a starting point. Then to assist with the build process, the <code class="language-plaintext highlighter-rouge">USER</code> is specified. The last argument in the file facilitates install of some libraries without necessity to interact with the user during the process. More information on this can be found below.</p>

<p><a href="https://stackoverflow.com/questions/63476497/docker-build-with-ubuntu-18-04-image-hangs-after-prompting-for-country-of-origin">https://stackoverflow.com/questions/63476497/docker-build-with-ubuntu-18-04-image-hangs-after-prompting-for-country-of-origin</a></p>

<p>Then, let’s try and run a system update to validate we can successfully install packages.</p>

<h3 id="dockerfile">Dockerfile</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM nvidia/cuda:11.1.1-devel-ubuntu20.04

USER root

# disable interactive configuration mode
ENV DEBIAN_FRONTEND noninteractive

RUN apt-get update \
    &amp;&amp; \
    apt-get install -y \
    &amp;&amp; \
    rm -rf /var/lib/apt/lists/* \
    &amp;&amp; \
    update-locale LANG=en_US.UTF-8 LC_MESSAGES=POSIX
</code></pre></div></div>

<p>Save the file. We then need to try and build the image for the first time. Using the <code class="language-plaintext highlighter-rouge">build</code> command, the <code class="language-plaintext highlighter-rouge">-t</code> argument is used to tag the image. This tag takes the username first followed by the image name. The <code class="language-plaintext highlighter-rouge">-f</code> argument is used to use the point the build process to the file we want that includes the build instructions, in this case the <code class="language-plaintext highlighter-rouge">Dockerfile.base</code> file just created.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">holmech@linux-desktop:~$</span><span class="w"> </span>docker build <span class="nt">-t</span> holmec/noetic-base <span class="nt">-f</span> Dockerfile.base <span class="nb">.</span>
</code></pre></div></div>

<p>The command may take some time to complete. A successful build should have the following terminal output.</p>]]></content><author><name>C. Holmes</name></author><summary type="html"><![CDATA[This post outlines how to create a Docker environment with ROS middleware setup.]]></summary></entry><entry><title type="html">Face Detection (hog &amp;amp; Svm)</title><link href="http://localhost:4000/2023/11/23/Face-Detection-(HOG-&-SVM).html" rel="alternate" type="text/html" title="Face Detection (hog &amp;amp; Svm)" /><published>2023-11-23T00:00:00+00:00</published><updated>2023-11-23T00:00:00+00:00</updated><id>http://localhost:4000/2023/11/23/Face-Detection-(HOG-&amp;-SVM)</id><content type="html" xml:base="http://localhost:4000/2023/11/23/Face-Detection-(HOG-&amp;-SVM).html"><![CDATA[<p>This post outlines using Histogram of Gradients (HOG) &amp; Support Vector Machines (SVM) for face detection with OpenCV.</p>]]></content><author><name>C. Holmes</name></author><summary type="html"><![CDATA[This post outlines using Histogram of Gradients (HOG) &amp; Support Vector Machines (SVM) for face detection with OpenCV.]]></summary></entry><entry><title type="html">Linear &amp;amp; Logistic Regression</title><link href="http://localhost:4000/2023/11/23/Linear-&-Logistic-Regression.html" rel="alternate" type="text/html" title="Linear &amp;amp; Logistic Regression" /><published>2023-11-23T00:00:00+00:00</published><updated>2023-11-23T00:00:00+00:00</updated><id>http://localhost:4000/2023/11/23/Linear-&amp;-Logistic-Regression</id><content type="html" xml:base="http://localhost:4000/2023/11/23/Linear-&amp;-Logistic-Regression.html"><![CDATA[<p>An outline of creating linear and logistic regression with C++.</p>]]></content><author><name>C. Holmes</name></author><summary type="html"><![CDATA[An outline of creating linear and logistic regression with C++.]]></summary></entry><entry><title type="html">Playstation 4 Controller With Can</title><link href="http://localhost:4000/2023/11/23/Playstation-4-Controller-with-CAN.html" rel="alternate" type="text/html" title="Playstation 4 Controller With Can" /><published>2023-11-23T00:00:00+00:00</published><updated>2023-11-23T00:00:00+00:00</updated><id>http://localhost:4000/2023/11/23/Playstation-4-Controller-with-CAN</id><content type="html" xml:base="http://localhost:4000/2023/11/23/Playstation-4-Controller-with-CAN.html"><![CDATA[<p>Communicating Playstation 4 games controller inputs using CAN.</p>]]></content><author><name>C. Holmes</name></author><summary type="html"><![CDATA[Communicating Playstation 4 games controller inputs using CAN.]]></summary></entry></feed>